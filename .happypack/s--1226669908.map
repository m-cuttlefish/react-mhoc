{"version":3,"sources":["node_modules/react-dom/lib/ReactUpdateQueue.js"],"names":["_prodInvariant","require","ReactCurrentOwner","ReactInstanceMap","ReactInstrumentation","ReactUpdates","invariant","warning","enqueueUpdate","internalInstance","formatUnexpectedArgument","arg","type","displayName","constructor","name","keys","Object","length","join","getInternalInstanceReadyForUpdate","publicInstance","callerName","get","process","env","NODE_ENV","ctor","current","ReactUpdateQueue","isMounted","owner","_warnedAboutRefsInRender","getName","_renderedComponent","enqueueCallback","callback","validateCallback","_pendingCallbacks","push","enqueueCallbackInternal","enqueueForceUpdate","_pendingForceUpdate","enqueueReplaceState","completeState","_pendingStateQueue","_pendingReplaceState","undefined","enqueueSetState","partialState","debugTool","onSetState","queue","enqueueElementInternal","nextElement","nextContext","_pendingElement","_context","module","exports"],"mappings":"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","file":"ReactUpdateQueue.js","sourceRoot":"/Users/moyu/my-code/FECode/react-hoc","sourcesContent":["/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactInstrumentation = require('./ReactInstrumentation');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction formatUnexpectedArgument(arg) {\n  var type = typeof arg;\n  if (type !== 'object') {\n    return type;\n  }\n  var displayName = arg.constructor && arg.constructor.name || type;\n  var keys = Object.keys(arg);\n  if (keys.length > 0 && keys.length < 20) {\n    return displayName + ' (keys: ' + keys.join(', ') + ')';\n  }\n  return displayName;\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var ctor = publicInstance.constructor;\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;\n    }\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + \"within `render` or another component's constructor). Render methods \" + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @param {string} callerName Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback, callerName) {\n    ReactUpdateQueue.validateCallback(callback, callerName);\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function (internalInstance, callback) {\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    // Future-proof 15.5\n    if (callback !== undefined && callback !== null) {\n      ReactUpdateQueue.validateCallback(callback, 'replaceState');\n      if (internalInstance._pendingCallbacks) {\n        internalInstance._pendingCallbacks.push(callback);\n      } else {\n        internalInstance._pendingCallbacks = [callback];\n      }\n    }\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    if (process.env.NODE_ENV !== 'production') {\n      ReactInstrumentation.debugTool.onSetState();\n      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;\n    }\n\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {\n    internalInstance._pendingElement = nextElement;\n    // TODO: introduce _pendingContext instead of setting it directly.\n    internalInstance._context = nextContext;\n    enqueueUpdate(internalInstance);\n  },\n\n  validateCallback: function (callback, callerName) {\n    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;\n  }\n};\n\nmodule.exports = ReactUpdateQueue;"]}