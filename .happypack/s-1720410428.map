{"version":3,"sources":["node_modules/react-dom/lib/ReactDOMTreeTraversal.js"],"names":["_prodInvariant","require","invariant","getLowestCommonAncestor","instA","instB","process","env","NODE_ENV","depthA","tempA","_hostParent","depthB","tempB","depth","isAncestor","getParentInstance","inst","traverseTwoPhase","fn","arg","path","push","i","length","traverseEnterLeave","from","to","argFrom","argTo","common","pathFrom","pathTo","module","exports"],"mappings":"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","file":"ReactDOMTreeTraversal.js","sourceRoot":"/Users/moyu/my-code/FECode/react-hoc","sourcesContent":["/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = tempA._hostParent) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = tempB._hostParent) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = instA._hostParent;\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = instB._hostParent;\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB) {\n      return instA;\n    }\n    instA = instA._hostParent;\n    instB = instB._hostParent;\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n\n  while (instB) {\n    if (instB === instA) {\n      return true;\n    }\n    instB = instB._hostParent;\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;\n\n  return inst._hostParent;\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = inst._hostParent;\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (from && from !== common) {\n    pathFrom.push(from);\n    from = from._hostParent;\n  }\n  var pathTo = [];\n  while (to && to !== common) {\n    pathTo.push(to);\n    to = to._hostParent;\n  }\n  var i;\n  for (i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (i = pathTo.length; i-- > 0;) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}\n\nmodule.exports = {\n  isAncestor: isAncestor,\n  getLowestCommonAncestor: getLowestCommonAncestor,\n  getParentInstance: getParentInstance,\n  traverseTwoPhase: traverseTwoPhase,\n  traverseEnterLeave: traverseEnterLeave\n};"]}